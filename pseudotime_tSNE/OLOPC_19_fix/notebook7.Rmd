```{r SCN3E-setup, message=FALSE}
library(destiny)      # for Transitions(), DPT
library(e1071)        # for svm()
library(amap)         # for Dist()
library(igraph)       # for graph + community detection
library(Seurat)       # to extract counts
library(ggplot2)
library(viridis)
library(shadowtext)
```

```{r}
names(OLOPC_19_fix@assays)
```

```{r}
#explicitly naming the assay:
counts_mat <- as.matrix(
  GetAssayData(
    object = OLOPC_19_fix,
    assay  = "RNA", 
    layer   = "counts"
  )
)
DefaultAssay(OLOPC_19_fix) <- "RNA"
counts_mat <- as.matrix( GetAssayData(OLOPC_19_fix, slot = "counts") )
```


```{r feature selection}
#keep genes expressed ≥1 in at least one cell
expressed <- rowSums(counts_mat >= 1) > 0
emat <- counts_mat[expressed,]

# Compute log-mean & CV^2
CVsq <- function(x) (sd(x)/mean(x))^2
meancounts <- rowMeans(emat)
CV2         <- apply(emat, 1, CVsq)
df <- data.frame(
  LogExpr = log(meancounts),
  CV2     = log(CV2)
)

# Fit SVR line & pick high‐variance genes
svr_mod    <- svm(CV2 ~ LogExpr, data = df, gamma = 0.06)
predicted  <- predict(svr_mod, df)
df$relVar  <- df$CV2 - predicted
# threshold of 0.5 above trend
highVar    <- which(df$relVar >= 0.5)
NormGenes  <- rownames(df)[highVar]
length(NormGenes)  # how many HVGs
```

```{r build DPT}
# build the diffusion map 
expr_log <- t(log1p(emat[NormGenes,]))
dm       <- DiffusionMap(expr_log)

# run DPT to get pseudotime
pt       <- DPT(dm)
```

##code block before are correct

```{r}
#branches or lineages within the cell population based on the tips and the underlying diffusion map. Each branch represents a distinct developmental pathway or trajectory. 
head(pt@branch)
```


```{r}
#starting points or nodes that are used to calculate the DPT values
head(pt@tips)
```
```{r}
pt@dm
```

```{r}
# Count branch matrix
tip_sizes_branch <- colSums(!is.na(pt@branch))
sort(tip_sizes_branch, decreasing = TRUE)

```
```{r}
#use top 3 branches
big3             <- order(tip_sizes_branch, decreasing=TRUE)[1:5]
big3
```


```{r}
branches3 <- apply(pt@branch[, big3, drop=FALSE], 1, function(x) {
  i <- which(!is.na(x))[3]    # first non-NA tip
  if (length(i)==0) return(NA_integer_)
  i
})

#Check really got three non‐NA groups of the expected sizes
table(branches3, useNA = "ifany")

```

```{r}
branches3
```



```{r}
# after extract the eigenvectors from destiny
dc_mat <- dm@eigenvectors[, -1, drop = FALSE]
# make sure the rownames are the cell‐barcodes
rownames(dc_mat) <- rownames(dm@eigenvectors)  

# keep the DC labels on the column names
colnames(dc_mat) <- paste0("DC", seq_len(ncol(dc_mat)))

# compute the cell–cell distance matrix
dist_mat <- as.matrix(
  amap::Dist(dc_mat, method = "euclidean", nbproc = 8)
)

# build Pearson weight matrix
pearson_mat <- cor(t(dc_mat))^5 

# build kNN+thresholded edges among:
k      <- 15
cutoff <- 0.5
edges_list <- lapply(seq_len(nrow(dist_mat)), function(i) {
  # i indexes **rows** = cells
  this_cell <- rownames(dist_mat)[i]
  # find k nearest neighbours by distance
  nn   <- order(dist_mat[i, ])[2:(k+1)]
  # their correlations
  corrs <- pearson_mat[i, nn]
  keep <- which(corrs > cutoff)
  if (length(keep)==0) return(NULL)
  data.frame(
    from   = this_cell,
    to     = rownames(dist_mat)[nn[keep]],
    weight = corrs[keep],
    stringsAsFactors=FALSE
  )
})
edges <- do.call(rbind, Filter(Negate(is.null), edges_list))

```


```{r}
library(igraph)

# Start over from edges data.frame, to be sure g is entirely fresh:
g <- graph_from_data_frame(edges, directed = FALSE)

# drop any edges weight is NA or non-numeric
bad_edges <- which(!is.finite(E(g)$weight))
if (length(bad_edges)) {
  message("Removing ", length(bad_edges), " NA/non-finite edges")
  g <- delete_edges(g, E(g)[bad_edges])
}

# drop loops, merge parallel edges keeping the max weight
g <- simplify(
  g,
  remove.multiple = TRUE,
  remove.loops    = TRUE,
  edge.attr.comb  = list(weight = "max")
)

# 3) Delete vertices with degree 0
isolates <- V(g)[degree(g) == 0]
if (length(isolates)) {
  message("Dropping ", length(isolates), " isolated vertices")
  g <- delete_vertices(g, isolates)
}

# 4) Verify the integrity
cat("After cleanup:\n")
cat(" vertices:", vcount(g), "\n")
cat(" edges:   ", ecount(g), "\n")
stopifnot(!any(is.na(E(g)$weight)))
stopifnot(all(is.finite(E(g)$weight)))
stopifnot(is.numeric(E(g)$weight))

layout_auto <- layout_nicely(g)
plot(g, layout = layout_auto, vertex.size=1, vertex.label=NA, edge.color="grey80")


```

```{r}
library(ggplot2)
library(ggforce)
library(viridis)

# 1) Extract DC2/DC3 coordinates from  DiffusionMap:
dc_coords <- as.data.frame(dm@eigenvectors[, 2:3])
colnames(dc_coords) <- c("X", "Y")
dc_coords$cell <- rownames(dc_coords)

# 2) Build a node‐metadata frame
node_df <- dc_coords
node_df$branch <- factor(pt@branch[,1][node_df$cell],
                         levels=c(1,2,3),
                         labels=c("Arm1","Arm2","Arm3"))

# 3) Turn to igraph object into an edge‐list with coordinates:
el <- as_data_frame(g, what="edges")
el$x1 <- dc_coords$X[ match(el$from, dc_coords$cell) ]
el$y1 <- dc_coords$Y[ match(el$from, dc_coords$cell) ]
el$x2 <- dc_coords$X[ match(el$to,   dc_coords$cell) ]
el$y2 <- dc_coords$Y[ match(el$to,   dc_coords$cell) ]

# 4) Plot with ggplot2 + ggforce:
ggplot() +
  geom_segment(data=el,
               aes(x=x1,y=y1,xend=x2,yend=y2),
               color="grey80", size=0.2, alpha=0.4) +
  geom_point(data=node_df,
             aes(x=X,y=Y,color=branch),
             size=1.2) +
  scale_color_viridis_d(option="D", name="Branch") +
  theme_void() +
  ggtitle("SCN3E Network Embedding\n(DC2 vs DC3)")

```

```{r}
library(ggplot2)
library(ggforce)
library(viridis)
library(igraph)

# 1) Extract DC2/DC3 coordinates from your DiffusionMap:
dc_coords <- as.data.frame(dm@eigenvectors[, 2:3])
colnames(dc_coords) <- c("X", "Y")
dc_coords$cell <- rownames(dc_coords)

# 2) Build a node‐metadata frame and pull in the Seurat cluster
node_df <- dc_coords
node_df$cluster <- factor(
  OLOPC_19_fix@meta.data[node_df$cell, "cluster"], 
  levels = c("OPC","COP","NFOL","MOL_DA","MOL")
)

# 3) Turn your igraph object into an edge‐list with coordinates:
el <- as_data_frame(g, what="edges")
el$x1 <- dc_coords$X[ match(el$from, dc_coords$cell) ]
el$y1 <- dc_coords$Y[ match(el$from, dc_coords$cell) ]
el$x2 <- dc_coords$X[ match(el$to,   dc_coords$cell) ]
el$y2 <- dc_coords$Y[ match(el$to,   dc_coords$cell) ]

# 4) Plot with ggplot2 + ggforce, coloring by Seurat cluster:
ggplot() +
  geom_segment(data=el,
               aes(x=x1,y=y1,xend=x2,yend=y2),
               color="grey80", size=0.2, alpha=0.4) +
  geom_point(data=node_df,
             aes(x=X,y=Y, color=cluster),
             size=1.2) +
  scale_color_viridis_d(name="Cell Type", 
                        option="A",
                        begin=0.2, end=0.8) +
  theme_void() +
  ggtitle("SCN3E Network Embedding\n(DC2 vs DC3, colored by cluster)")

```

```{r check celltype in each arm}
ct_by_arm <- table(
  Arm      = branches3[names(branches3)],
  CellType = OLOPC_19_fix@meta.data$cluster
)

print(ct_by_arm)
```

| Arm |  OPC | COP | NFOL | MOL_DA |  MOL |
|   1 | 1587 | 277 |  232 |     747 | 6940 |
|   2 | 1261 | 212 |  124 |     747 | 6940 |
|   3 |  856 | 125 |   93 |     569 | 5592 |

| Arm |  OPC |  COP | NFOL | MOL_DA |  MOL |
|   1 | 0.17 | 0.03 | 0.03 |    0.08 | 0.69 |
|   2 | 0.15 | 0.03 | 0.01 |    0.09 | 0.72 |
|   3 | 0.10 | 0.02 | 0.01 |    0.07 | 0.80 |

Arm 1: OPC/COP/NFOL
Arm 2: MOL_DA
Arm 3: MOL

```{r}
unique(OLOPC_19_fix$predicted.cluster)
```

```{r}
unique(OLOPC_19_fix$predicted.subclass)
```

```{r}
unique(OLOPC_19_fix$cluster)
```

